LAB EXERCISE – Traffic Light Controller with Pedestrian Request Button using LPC2148
Aim

To write and execute an ARM7 LPC2148 program for a traffic light controller that controls two road signals and a pedestrian crossing, with a pedestrian request button to override the normal cycle.


===========================
Apparatus Required

LPC2148 Development Board

16×2 LCD Display

4×4 Matrix Keypad (for pedestrian button input)

LEDs (for traffic light indication)

Flash Magic Programmer

==============================
Procedure

1) Initialize GPIO pins

  Configure LCD control pins (RS, EN) and data pins (P1.16–P1.23) as outputs.
  
  Configure LED pins (P1.24–P1.31) as outputs for traffic light simulation.
  
  Set keypad row pins (P0.16–P0.19) as outputs and column pins (P0.20–P0.23) as inputs.

2) Initialize the LCD

  Send the command sequence {0x38, 0x01, 0x06, 0x0C, 0x80} to set 8-bit mode, clear display, set entry mode, turn on display, and set cursor position.

3) Display start-up message

  Print "Traffic Control" on the first LCD line.
  
  Print "...Starting...." on the second line.
  
  Turn on all LEDs briefly to indicate system start-up.

4) Enter infinite loop for traffic control

  Always display "ifYouCross: Hold" on the LCD second line to indicate waiting for pedestrian input.

5) Scan keypad for pedestrian request

  Drive each row low one at a time, read column pins to detect if any key is pressed.
  
  If the 'C' key is pressed, trigger pedestrian crossing mode.

6) Pedestrian crossing mode

  Display "R1:R R2:R H:Go" on the LCD.
  
  Turn on red LEDs for both roads and green LED for pedestrian crossing.
  
  Hold state for a fixed delay, then turn off LEDs.

7) Normal traffic cycle mode

  Display "R1:R R2:G H:Stop", turn on red LED for R1, green for R2, pedestrian red. Delay.
  
  Then display "R1:G R2:R H:Stop", turn on green LED for R1, red for R2, pedestrian red. Delay.
  
  Repeat until pedestrian request is detected.


===========================
program:



#include <nxp/iolpc2148.h>

#define rs IO0PIN_bit.P0_8
#define en IO0PIN_bit.P0_11

// LCD init commands
unsigned char commandarray[5] = {0x38, 0x01, 0x06, 0x0c, 0x80};

void delay(unsigned int x) {
    unsigned int i;
    for (i = 0; i < x; i++);
}

void lcd_init() {
    int i;
    for (i = 0; i < 5; i++) {
        IO1PIN = commandarray[i] << 16;
        rs = 0;
        en = 1;
        delay(4095);
        en = 0;
    }
}

void lcd_command(unsigned char cmd) {
    IO1PIN = cmd << 16;
    rs = 0;
    en = 1;
    delay(4095);
    en = 0;
}

void lcd_print(char data[]) {
    int i;
    for (i = 0; data[i] != '\0'; i++) {
        IO1PIN = data[i] << 16;
        rs = 1;
        en = 1;
        delay(4095);
        en = 0;
    }
}

// Corrected keypad scan function
char get_key() {
    int row_vals[] = {0x000E0000, 0x000D0000, 0x000B0000, 0x00070000};
    char key_map[4][4] = {
        {'1', '2', '3', '+'},
        {'4', '5', '6', '-'},
        {'7', '8', '9', '*'},
        {'C', '0', '=', '/'}
    };

    int row, col;

    for (row = 0; row < 4; row++) {
        // Clear all rows (P0.16-P0.19)
        IO0SET = 0x000F0000;    // set rows high
        IO0CLR = (~row_vals[row]) & 0x000F0000; // drive current row low

        delay(1000);

        int col_val = IO0PIN & 0x00F00000; // read cols P0.20-P0.23

        if (col_val != 0x00F00000) { // some col is low (pressed)
            for (col = 0; col < 4; col++) {
                if ((col_val & (1 << (20 + col))) == 0) {
                    // wait for release
                    while ((IO0PIN & 0x00F00000) != 0x00F00000);
                    return key_map[row][col];
                }
            }
        }
    }
    return 0;
}

int main() {
    char key = 0;

    // Configure pins:
    PINSEL0 = 0x00000000; // GPIO function for P0 pins
    PINSEL2 = 0x00000000; // GPIO function for P1 pins

    // Keypad rows (P0.16-P0.19) output
    IO0DIR |= 0x000F0000;

    // Keypad columns (P0.20-P0.23) input
    IO0DIR &= ~0x00F00000;

    // LCD control pins output
    IO0DIR_bit.P0_8 = 1;  // rs
    IO0DIR_bit.P0_11 = 1; // en

    // LCD data pins output (P1.16-P1.23)
    IO1DIR |= 0x00FF0000;

    // LEDs output (P1.24-P1.31)
    IO1DIR |= 0xFF000000;

    lcd_init();
    lcd_command(0x80);
    lcd_print("Traffic Control");
    lcd_command(0xC0);
    lcd_print("...Starting....");
    IO1SET = 0xDB000000; // leds on
    delay(950000);
    IO1CLR = 0xFF000000; // leds off

    while (1) {
        lcd_command(0xC0);
        lcd_print("ifYouCross: Hold");
        key = get_key();  // scan keypad
        delay(550000);
        if (key == 'C') {
            lcd_command(0xC0);
            lcd_print("R1:R R2:R H:Go  ");
            IO1SET = 0x81000000;  // LEDs ON
            delay(1000000);
            IO1CLR = 0xFF000000;  // LEDs OFF
        } else {
            // Normal traffic light cycle
            lcd_command(0xC0);
            lcd_print("R1:R R2:G H:Stop");
            IO1SET = 0x51000000;
            delay(950000);
            IO1CLR = 0xFF000000;

            lcd_command(0xC0);
            lcd_print("R1:G R2:R H:Stop");
            IO1SET = 0x4A000000;
            delay(950000);
            IO1CLR = 0xFF000000;
        }
    }
    return 0;
}


================================

Result

The program for traffic light controller with pedestrian request button was successfully implemented and executed using the LPC2148 ARM7 microcontroller.
